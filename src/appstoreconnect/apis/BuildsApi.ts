/* tslint:disable */
/* eslint-disable */
/**
 * App Store Connect API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import type { AppEncryptionDeclarationResponse, AppResponse, AppStoreVersionResponse, BetaAppReviewSubmissionResponse, BetaBuildLocalizationsResponse, BetaTestersResponse, BuildAppEncryptionDeclarationLinkageRequest, BuildAppEncryptionDeclarationLinkageResponse, BuildBetaDetailResponse, BuildBetaGroupsLinkagesRequest, BuildIconsResponse, BuildIndividualTestersLinkagesRequest, BuildIndividualTestersLinkagesResponse, BuildResponse, BuildUpdateRequest, BuildsResponse, DiagnosticSignaturesResponse, ErrorResponse, PrereleaseVersionResponse, XcodeMetrics, } from '../models';
import { AppEncryptionDeclarationResponseFromJSON, AppEncryptionDeclarationResponseToJSON, AppResponseFromJSON, AppResponseToJSON, AppStoreVersionResponseFromJSON, AppStoreVersionResponseToJSON, BetaAppReviewSubmissionResponseFromJSON, BetaAppReviewSubmissionResponseToJSON, BetaBuildLocalizationsResponseFromJSON, BetaBuildLocalizationsResponseToJSON, BetaTestersResponseFromJSON, BetaTestersResponseToJSON, BuildAppEncryptionDeclarationLinkageRequestFromJSON, BuildAppEncryptionDeclarationLinkageRequestToJSON, BuildAppEncryptionDeclarationLinkageResponseFromJSON, BuildAppEncryptionDeclarationLinkageResponseToJSON, BuildBetaDetailResponseFromJSON, BuildBetaDetailResponseToJSON, BuildBetaGroupsLinkagesRequestFromJSON, BuildBetaGroupsLinkagesRequestToJSON, BuildIconsResponseFromJSON, BuildIconsResponseToJSON, BuildIndividualTestersLinkagesRequestFromJSON, BuildIndividualTestersLinkagesRequestToJSON, BuildIndividualTestersLinkagesResponseFromJSON, BuildIndividualTestersLinkagesResponseToJSON, BuildResponseFromJSON, BuildResponseToJSON, BuildUpdateRequestFromJSON, BuildUpdateRequestToJSON, BuildsResponseFromJSON, BuildsResponseToJSON, DiagnosticSignaturesResponseFromJSON, DiagnosticSignaturesResponseToJSON, ErrorResponseFromJSON, ErrorResponseToJSON, PrereleaseVersionResponseFromJSON, PrereleaseVersionResponseToJSON, XcodeMetricsFromJSON, XcodeMetricsToJSON, } from '../models';
export interface BuildsAppEncryptionDeclarationGetToOneRelatedRequest {
    id: string;
    fieldsAppEncryptionDeclarations?: Array<BuildsAppEncryptionDeclarationGetToOneRelatedFieldsAppEncryptionDeclarationsEnum>;
}
export interface BuildsAppEncryptionDeclarationGetToOneRelationshipRequest {
    id: string;
}
export interface BuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest {
    id: string;
    buildAppEncryptionDeclarationLinkageRequest: BuildAppEncryptionDeclarationLinkageRequest;
}
export interface BuildsAppGetToOneRelatedRequest {
    id: string;
    fieldsApps?: Array<BuildsAppGetToOneRelatedFieldsAppsEnum>;
}
export interface BuildsAppStoreVersionGetToOneRelatedRequest {
    id: string;
    fieldsAppStoreVersionExperiments?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionExperimentsEnum>;
    fieldsAgeRatingDeclarations?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAgeRatingDeclarationsEnum>;
    fieldsAppStoreVersionSubmissions?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionSubmissionsEnum>;
    fieldsAppStoreReviewDetails?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreReviewDetailsEnum>;
    fieldsAppStoreVersions?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionsEnum>;
    fieldsApps?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppsEnum>;
    fieldsRoutingAppCoverages?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsRoutingAppCoveragesEnum>;
    fieldsAppClipDefaultExperiences?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppClipDefaultExperiencesEnum>;
    fieldsAppStoreVersionPhasedReleases?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionPhasedReleasesEnum>;
    fieldsBuilds?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsBuildsEnum>;
    fieldsAppStoreVersionLocalizations?: Array<BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionLocalizationsEnum>;
    limitAppStoreVersionLocalizations?: number;
    limitAppStoreVersionExperiments?: number;
    include?: Array<BuildsAppStoreVersionGetToOneRelatedIncludeEnum>;
}
export interface BuildsBetaAppReviewSubmissionGetToOneRelatedRequest {
    id: string;
    fieldsBetaAppReviewSubmissions?: Array<BuildsBetaAppReviewSubmissionGetToOneRelatedFieldsBetaAppReviewSubmissionsEnum>;
}
export interface BuildsBetaBuildLocalizationsGetToManyRelatedRequest {
    id: string;
    fieldsBetaBuildLocalizations?: Array<BuildsBetaBuildLocalizationsGetToManyRelatedFieldsBetaBuildLocalizationsEnum>;
    limit?: number;
}
export interface BuildsBetaGroupsCreateToManyRelationshipRequest {
    id: string;
    buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest;
}
export interface BuildsBetaGroupsDeleteToManyRelationshipRequest {
    id: string;
    buildBetaGroupsLinkagesRequest: BuildBetaGroupsLinkagesRequest;
}
export interface BuildsBuildBetaDetailGetToOneRelatedRequest {
    id: string;
    fieldsBuildBetaDetails?: Array<BuildsBuildBetaDetailGetToOneRelatedFieldsBuildBetaDetailsEnum>;
}
export interface BuildsDiagnosticSignaturesGetToManyRelatedRequest {
    id: string;
    filterDiagnosticType?: Array<BuildsDiagnosticSignaturesGetToManyRelatedFilterDiagnosticTypeEnum>;
    fieldsDiagnosticSignatures?: Array<BuildsDiagnosticSignaturesGetToManyRelatedFieldsDiagnosticSignaturesEnum>;
    limit?: number;
}
export interface BuildsGetCollectionRequest {
    filterBetaAppReviewSubmissionBetaReviewState?: Array<BuildsGetCollectionFilterBetaAppReviewSubmissionBetaReviewStateEnum>;
    filterBuildAudienceType?: Array<BuildsGetCollectionFilterBuildAudienceTypeEnum>;
    filterExpired?: Array<string>;
    filterPreReleaseVersionPlatform?: Array<BuildsGetCollectionFilterPreReleaseVersionPlatformEnum>;
    filterPreReleaseVersionVersion?: Array<string>;
    filterProcessingState?: Array<BuildsGetCollectionFilterProcessingStateEnum>;
    filterUsesNonExemptEncryption?: Array<string>;
    filterVersion?: Array<string>;
    filterApp?: Array<string>;
    filterAppStoreVersion?: Array<string>;
    filterBetaGroups?: Array<string>;
    filterPreReleaseVersion?: Array<string>;
    filterId?: Array<string>;
    sort?: Array<BuildsGetCollectionSortEnum>;
    fieldsBuilds?: Array<BuildsGetCollectionFieldsBuildsEnum>;
    limit?: number;
    include?: Array<BuildsGetCollectionIncludeEnum>;
    fieldsDiagnosticSignatures?: Array<BuildsGetCollectionFieldsDiagnosticSignaturesEnum>;
    fieldsBuildIcons?: Array<BuildsGetCollectionFieldsBuildIconsEnum>;
    fieldsBuildBetaDetails?: Array<BuildsGetCollectionFieldsBuildBetaDetailsEnum>;
    fieldsBetaAppReviewSubmissions?: Array<BuildsGetCollectionFieldsBetaAppReviewSubmissionsEnum>;
    fieldsBetaTesters?: Array<BuildsGetCollectionFieldsBetaTestersEnum>;
    fieldsAppStoreVersions?: Array<BuildsGetCollectionFieldsAppStoreVersionsEnum>;
    fieldsBetaBuildLocalizations?: Array<BuildsGetCollectionFieldsBetaBuildLocalizationsEnum>;
    fieldsPreReleaseVersions?: Array<BuildsGetCollectionFieldsPreReleaseVersionsEnum>;
    fieldsAppEncryptionDeclarations?: Array<BuildsGetCollectionFieldsAppEncryptionDeclarationsEnum>;
    fieldsApps?: Array<BuildsGetCollectionFieldsAppsEnum>;
    fieldsPerfPowerMetrics?: Array<BuildsGetCollectionFieldsPerfPowerMetricsEnum>;
    limitBetaBuildLocalizations?: number;
    limitBetaGroups?: number;
    limitBuildBundles?: number;
    limitIcons?: number;
    limitIndividualTesters?: number;
}
export interface BuildsGetInstanceRequest {
    id: string;
    fieldsBuilds?: Array<BuildsGetInstanceFieldsBuildsEnum>;
    include?: Array<BuildsGetInstanceIncludeEnum>;
    fieldsDiagnosticSignatures?: Array<BuildsGetInstanceFieldsDiagnosticSignaturesEnum>;
    fieldsBuildIcons?: Array<BuildsGetInstanceFieldsBuildIconsEnum>;
    fieldsBuildBetaDetails?: Array<BuildsGetInstanceFieldsBuildBetaDetailsEnum>;
    fieldsBetaAppReviewSubmissions?: Array<BuildsGetInstanceFieldsBetaAppReviewSubmissionsEnum>;
    fieldsBetaTesters?: Array<BuildsGetInstanceFieldsBetaTestersEnum>;
    fieldsAppStoreVersions?: Array<BuildsGetInstanceFieldsAppStoreVersionsEnum>;
    fieldsBetaBuildLocalizations?: Array<BuildsGetInstanceFieldsBetaBuildLocalizationsEnum>;
    fieldsPreReleaseVersions?: Array<BuildsGetInstanceFieldsPreReleaseVersionsEnum>;
    fieldsAppEncryptionDeclarations?: Array<BuildsGetInstanceFieldsAppEncryptionDeclarationsEnum>;
    fieldsApps?: Array<BuildsGetInstanceFieldsAppsEnum>;
    fieldsPerfPowerMetrics?: Array<BuildsGetInstanceFieldsPerfPowerMetricsEnum>;
    limitBetaBuildLocalizations?: number;
    limitBetaGroups?: number;
    limitBuildBundles?: number;
    limitIcons?: number;
    limitIndividualTesters?: number;
}
export interface BuildsIconsGetToManyRelatedRequest {
    id: string;
    fieldsBuildIcons?: Array<BuildsIconsGetToManyRelatedFieldsBuildIconsEnum>;
    limit?: number;
}
export interface BuildsIndividualTestersCreateToManyRelationshipRequest {
    id: string;
    buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest;
}
export interface BuildsIndividualTestersDeleteToManyRelationshipRequest {
    id: string;
    buildIndividualTestersLinkagesRequest: BuildIndividualTestersLinkagesRequest;
}
export interface BuildsIndividualTestersGetToManyRelatedRequest {
    id: string;
    fieldsBetaTesters?: Array<BuildsIndividualTestersGetToManyRelatedFieldsBetaTestersEnum>;
    limit?: number;
}
export interface BuildsIndividualTestersGetToManyRelationshipRequest {
    id: string;
    limit?: number;
}
export interface BuildsPerfPowerMetricsGetToManyRelatedRequest {
    id: string;
    filterDeviceType?: Array<string>;
    filterMetricType?: Array<BuildsPerfPowerMetricsGetToManyRelatedFilterMetricTypeEnum>;
    filterPlatform?: Array<BuildsPerfPowerMetricsGetToManyRelatedFilterPlatformEnum>;
}
export interface BuildsPreReleaseVersionGetToOneRelatedRequest {
    id: string;
    fieldsPreReleaseVersions?: Array<BuildsPreReleaseVersionGetToOneRelatedFieldsPreReleaseVersionsEnum>;
}
export interface BuildsUpdateInstanceRequest {
    id: string;
    buildUpdateRequest: BuildUpdateRequest;
}
/**
 *
 */
export class BuildsApi extends runtime.BaseAPI {
    /**
     */
    async buildsAppEncryptionDeclarationGetToOneRelatedRaw(requestParameters: BuildsAppEncryptionDeclarationGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AppEncryptionDeclarationResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsAppEncryptionDeclarationGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsAppEncryptionDeclarations) {
            queryParameters['fields[appEncryptionDeclarations]'] = requestParameters.fieldsAppEncryptionDeclarations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/appEncryptionDeclaration`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => AppEncryptionDeclarationResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsAppEncryptionDeclarationGetToOneRelated(requestParameters: BuildsAppEncryptionDeclarationGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AppEncryptionDeclarationResponse> {
        const response = await this.buildsAppEncryptionDeclarationGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsAppEncryptionDeclarationGetToOneRelationshipRaw(requestParameters: BuildsAppEncryptionDeclarationGetToOneRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildAppEncryptionDeclarationLinkageResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsAppEncryptionDeclarationGetToOneRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/appEncryptionDeclaration`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildAppEncryptionDeclarationLinkageResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsAppEncryptionDeclarationGetToOneRelationship(requestParameters: BuildsAppEncryptionDeclarationGetToOneRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildAppEncryptionDeclarationLinkageResponse> {
        const response = await this.buildsAppEncryptionDeclarationGetToOneRelationshipRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsAppEncryptionDeclarationUpdateToOneRelationshipRaw(requestParameters: BuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsAppEncryptionDeclarationUpdateToOneRelationship.');
        }
        if (requestParameters.buildAppEncryptionDeclarationLinkageRequest === null || requestParameters.buildAppEncryptionDeclarationLinkageRequest === undefined) {
            throw new runtime.RequiredError('buildAppEncryptionDeclarationLinkageRequest', 'Required parameter requestParameters.buildAppEncryptionDeclarationLinkageRequest was null or undefined when calling buildsAppEncryptionDeclarationUpdateToOneRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/appEncryptionDeclaration`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BuildAppEncryptionDeclarationLinkageRequestToJSON(requestParameters.buildAppEncryptionDeclarationLinkageRequest),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async buildsAppEncryptionDeclarationUpdateToOneRelationship(requestParameters: BuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.buildsAppEncryptionDeclarationUpdateToOneRelationshipRaw(requestParameters, initOverrides);
    }
    /**
     */
    async buildsAppGetToOneRelatedRaw(requestParameters: BuildsAppGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AppResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsAppGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsApps) {
            queryParameters['fields[apps]'] = requestParameters.fieldsApps.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/app`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => AppResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsAppGetToOneRelated(requestParameters: BuildsAppGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AppResponse> {
        const response = await this.buildsAppGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsAppStoreVersionGetToOneRelatedRaw(requestParameters: BuildsAppStoreVersionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AppStoreVersionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsAppStoreVersionGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsAppStoreVersionExperiments) {
            queryParameters['fields[appStoreVersionExperiments]'] = requestParameters.fieldsAppStoreVersionExperiments.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAgeRatingDeclarations) {
            queryParameters['fields[ageRatingDeclarations]'] = requestParameters.fieldsAgeRatingDeclarations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersionSubmissions) {
            queryParameters['fields[appStoreVersionSubmissions]'] = requestParameters.fieldsAppStoreVersionSubmissions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreReviewDetails) {
            queryParameters['fields[appStoreReviewDetails]'] = requestParameters.fieldsAppStoreReviewDetails.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersions) {
            queryParameters['fields[appStoreVersions]'] = requestParameters.fieldsAppStoreVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsApps) {
            queryParameters['fields[apps]'] = requestParameters.fieldsApps.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsRoutingAppCoverages) {
            queryParameters['fields[routingAppCoverages]'] = requestParameters.fieldsRoutingAppCoverages.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppClipDefaultExperiences) {
            queryParameters['fields[appClipDefaultExperiences]'] = requestParameters.fieldsAppClipDefaultExperiences.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersionPhasedReleases) {
            queryParameters['fields[appStoreVersionPhasedReleases]'] = requestParameters.fieldsAppStoreVersionPhasedReleases.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuilds) {
            queryParameters['fields[builds]'] = requestParameters.fieldsBuilds.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersionLocalizations) {
            queryParameters['fields[appStoreVersionLocalizations]'] = requestParameters.fieldsAppStoreVersionLocalizations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limitAppStoreVersionLocalizations !== undefined) {
            queryParameters['limit[appStoreVersionLocalizations]'] = requestParameters.limitAppStoreVersionLocalizations;
        }
        if (requestParameters.limitAppStoreVersionExperiments !== undefined) {
            queryParameters['limit[appStoreVersionExperiments]'] = requestParameters.limitAppStoreVersionExperiments;
        }
        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/appStoreVersion`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => AppStoreVersionResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsAppStoreVersionGetToOneRelated(requestParameters: BuildsAppStoreVersionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AppStoreVersionResponse> {
        const response = await this.buildsAppStoreVersionGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsBetaAppReviewSubmissionGetToOneRelatedRaw(requestParameters: BuildsBetaAppReviewSubmissionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BetaAppReviewSubmissionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsBetaAppReviewSubmissionGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBetaAppReviewSubmissions) {
            queryParameters['fields[betaAppReviewSubmissions]'] = requestParameters.fieldsBetaAppReviewSubmissions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/betaAppReviewSubmission`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BetaAppReviewSubmissionResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsBetaAppReviewSubmissionGetToOneRelated(requestParameters: BuildsBetaAppReviewSubmissionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BetaAppReviewSubmissionResponse> {
        const response = await this.buildsBetaAppReviewSubmissionGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsBetaBuildLocalizationsGetToManyRelatedRaw(requestParameters: BuildsBetaBuildLocalizationsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BetaBuildLocalizationsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsBetaBuildLocalizationsGetToManyRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBetaBuildLocalizations) {
            queryParameters['fields[betaBuildLocalizations]'] = requestParameters.fieldsBetaBuildLocalizations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/betaBuildLocalizations`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BetaBuildLocalizationsResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsBetaBuildLocalizationsGetToManyRelated(requestParameters: BuildsBetaBuildLocalizationsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BetaBuildLocalizationsResponse> {
        const response = await this.buildsBetaBuildLocalizationsGetToManyRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsBetaGroupsCreateToManyRelationshipRaw(requestParameters: BuildsBetaGroupsCreateToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsBetaGroupsCreateToManyRelationship.');
        }
        if (requestParameters.buildBetaGroupsLinkagesRequest === null || requestParameters.buildBetaGroupsLinkagesRequest === undefined) {
            throw new runtime.RequiredError('buildBetaGroupsLinkagesRequest', 'Required parameter requestParameters.buildBetaGroupsLinkagesRequest was null or undefined when calling buildsBetaGroupsCreateToManyRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/betaGroups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BuildBetaGroupsLinkagesRequestToJSON(requestParameters.buildBetaGroupsLinkagesRequest),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async buildsBetaGroupsCreateToManyRelationship(requestParameters: BuildsBetaGroupsCreateToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.buildsBetaGroupsCreateToManyRelationshipRaw(requestParameters, initOverrides);
    }
    /**
     */
    async buildsBetaGroupsDeleteToManyRelationshipRaw(requestParameters: BuildsBetaGroupsDeleteToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsBetaGroupsDeleteToManyRelationship.');
        }
        if (requestParameters.buildBetaGroupsLinkagesRequest === null || requestParameters.buildBetaGroupsLinkagesRequest === undefined) {
            throw new runtime.RequiredError('buildBetaGroupsLinkagesRequest', 'Required parameter requestParameters.buildBetaGroupsLinkagesRequest was null or undefined when calling buildsBetaGroupsDeleteToManyRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/betaGroups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: BuildBetaGroupsLinkagesRequestToJSON(requestParameters.buildBetaGroupsLinkagesRequest),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async buildsBetaGroupsDeleteToManyRelationship(requestParameters: BuildsBetaGroupsDeleteToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.buildsBetaGroupsDeleteToManyRelationshipRaw(requestParameters, initOverrides);
    }
    /**
     */
    async buildsBuildBetaDetailGetToOneRelatedRaw(requestParameters: BuildsBuildBetaDetailGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildBetaDetailResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsBuildBetaDetailGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBuildBetaDetails) {
            queryParameters['fields[buildBetaDetails]'] = requestParameters.fieldsBuildBetaDetails.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/buildBetaDetail`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildBetaDetailResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsBuildBetaDetailGetToOneRelated(requestParameters: BuildsBuildBetaDetailGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildBetaDetailResponse> {
        const response = await this.buildsBuildBetaDetailGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsDiagnosticSignaturesGetToManyRelatedRaw(requestParameters: BuildsDiagnosticSignaturesGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DiagnosticSignaturesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsDiagnosticSignaturesGetToManyRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.filterDiagnosticType) {
            queryParameters['filter[diagnosticType]'] = requestParameters.filterDiagnosticType.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsDiagnosticSignatures) {
            queryParameters['fields[diagnosticSignatures]'] = requestParameters.fieldsDiagnosticSignatures.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/diagnosticSignatures`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => DiagnosticSignaturesResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsDiagnosticSignaturesGetToManyRelated(requestParameters: BuildsDiagnosticSignaturesGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DiagnosticSignaturesResponse> {
        const response = await this.buildsDiagnosticSignaturesGetToManyRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsGetCollectionRaw(requestParameters: BuildsGetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildsResponse>> {
        const queryParameters: any = {};
        if (requestParameters.filterBetaAppReviewSubmissionBetaReviewState) {
            queryParameters['filter[betaAppReviewSubmission.betaReviewState]'] = requestParameters.filterBetaAppReviewSubmissionBetaReviewState.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterBuildAudienceType) {
            queryParameters['filter[buildAudienceType]'] = requestParameters.filterBuildAudienceType.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterExpired) {
            queryParameters['filter[expired]'] = requestParameters.filterExpired.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterPreReleaseVersionPlatform) {
            queryParameters['filter[preReleaseVersion.platform]'] = requestParameters.filterPreReleaseVersionPlatform.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterPreReleaseVersionVersion) {
            queryParameters['filter[preReleaseVersion.version]'] = requestParameters.filterPreReleaseVersionVersion.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterProcessingState) {
            queryParameters['filter[processingState]'] = requestParameters.filterProcessingState.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterUsesNonExemptEncryption) {
            queryParameters['filter[usesNonExemptEncryption]'] = requestParameters.filterUsesNonExemptEncryption.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterVersion) {
            queryParameters['filter[version]'] = requestParameters.filterVersion.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterApp) {
            queryParameters['filter[app]'] = requestParameters.filterApp.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterAppStoreVersion) {
            queryParameters['filter[appStoreVersion]'] = requestParameters.filterAppStoreVersion.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterBetaGroups) {
            queryParameters['filter[betaGroups]'] = requestParameters.filterBetaGroups.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterPreReleaseVersion) {
            queryParameters['filter[preReleaseVersion]'] = requestParameters.filterPreReleaseVersion.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterId) {
            queryParameters['filter[id]'] = requestParameters.filterId.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.sort) {
            queryParameters['sort'] = requestParameters.sort.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuilds) {
            queryParameters['fields[builds]'] = requestParameters.fieldsBuilds.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsDiagnosticSignatures) {
            queryParameters['fields[diagnosticSignatures]'] = requestParameters.fieldsDiagnosticSignatures.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuildIcons) {
            queryParameters['fields[buildIcons]'] = requestParameters.fieldsBuildIcons.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuildBetaDetails) {
            queryParameters['fields[buildBetaDetails]'] = requestParameters.fieldsBuildBetaDetails.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaAppReviewSubmissions) {
            queryParameters['fields[betaAppReviewSubmissions]'] = requestParameters.fieldsBetaAppReviewSubmissions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaTesters) {
            queryParameters['fields[betaTesters]'] = requestParameters.fieldsBetaTesters.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersions) {
            queryParameters['fields[appStoreVersions]'] = requestParameters.fieldsAppStoreVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaBuildLocalizations) {
            queryParameters['fields[betaBuildLocalizations]'] = requestParameters.fieldsBetaBuildLocalizations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsPreReleaseVersions) {
            queryParameters['fields[preReleaseVersions]'] = requestParameters.fieldsPreReleaseVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppEncryptionDeclarations) {
            queryParameters['fields[appEncryptionDeclarations]'] = requestParameters.fieldsAppEncryptionDeclarations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsApps) {
            queryParameters['fields[apps]'] = requestParameters.fieldsApps.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsPerfPowerMetrics) {
            queryParameters['fields[perfPowerMetrics]'] = requestParameters.fieldsPerfPowerMetrics.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limitBetaBuildLocalizations !== undefined) {
            queryParameters['limit[betaBuildLocalizations]'] = requestParameters.limitBetaBuildLocalizations;
        }
        if (requestParameters.limitBetaGroups !== undefined) {
            queryParameters['limit[betaGroups]'] = requestParameters.limitBetaGroups;
        }
        if (requestParameters.limitBuildBundles !== undefined) {
            queryParameters['limit[buildBundles]'] = requestParameters.limitBuildBundles;
        }
        if (requestParameters.limitIcons !== undefined) {
            queryParameters['limit[icons]'] = requestParameters.limitIcons;
        }
        if (requestParameters.limitIndividualTesters !== undefined) {
            queryParameters['limit[individualTesters]'] = requestParameters.limitIndividualTesters;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildsResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsGetCollection(requestParameters: BuildsGetCollectionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildsResponse> {
        const response = await this.buildsGetCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsGetInstanceRaw(requestParameters: BuildsGetInstanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsGetInstance.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBuilds) {
            queryParameters['fields[builds]'] = requestParameters.fieldsBuilds.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.include) {
            queryParameters['include'] = requestParameters.include.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsDiagnosticSignatures) {
            queryParameters['fields[diagnosticSignatures]'] = requestParameters.fieldsDiagnosticSignatures.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuildIcons) {
            queryParameters['fields[buildIcons]'] = requestParameters.fieldsBuildIcons.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBuildBetaDetails) {
            queryParameters['fields[buildBetaDetails]'] = requestParameters.fieldsBuildBetaDetails.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaAppReviewSubmissions) {
            queryParameters['fields[betaAppReviewSubmissions]'] = requestParameters.fieldsBetaAppReviewSubmissions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaTesters) {
            queryParameters['fields[betaTesters]'] = requestParameters.fieldsBetaTesters.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppStoreVersions) {
            queryParameters['fields[appStoreVersions]'] = requestParameters.fieldsAppStoreVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsBetaBuildLocalizations) {
            queryParameters['fields[betaBuildLocalizations]'] = requestParameters.fieldsBetaBuildLocalizations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsPreReleaseVersions) {
            queryParameters['fields[preReleaseVersions]'] = requestParameters.fieldsPreReleaseVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsAppEncryptionDeclarations) {
            queryParameters['fields[appEncryptionDeclarations]'] = requestParameters.fieldsAppEncryptionDeclarations.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsApps) {
            queryParameters['fields[apps]'] = requestParameters.fieldsApps.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.fieldsPerfPowerMetrics) {
            queryParameters['fields[perfPowerMetrics]'] = requestParameters.fieldsPerfPowerMetrics.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limitBetaBuildLocalizations !== undefined) {
            queryParameters['limit[betaBuildLocalizations]'] = requestParameters.limitBetaBuildLocalizations;
        }
        if (requestParameters.limitBetaGroups !== undefined) {
            queryParameters['limit[betaGroups]'] = requestParameters.limitBetaGroups;
        }
        if (requestParameters.limitBuildBundles !== undefined) {
            queryParameters['limit[buildBundles]'] = requestParameters.limitBuildBundles;
        }
        if (requestParameters.limitIcons !== undefined) {
            queryParameters['limit[icons]'] = requestParameters.limitIcons;
        }
        if (requestParameters.limitIndividualTesters !== undefined) {
            queryParameters['limit[individualTesters]'] = requestParameters.limitIndividualTesters;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsGetInstance(requestParameters: BuildsGetInstanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildResponse> {
        const response = await this.buildsGetInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsIconsGetToManyRelatedRaw(requestParameters: BuildsIconsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildIconsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsIconsGetToManyRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBuildIcons) {
            queryParameters['fields[buildIcons]'] = requestParameters.fieldsBuildIcons.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/icons`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildIconsResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsIconsGetToManyRelated(requestParameters: BuildsIconsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildIconsResponse> {
        const response = await this.buildsIconsGetToManyRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsIndividualTestersCreateToManyRelationshipRaw(requestParameters: BuildsIndividualTestersCreateToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsIndividualTestersCreateToManyRelationship.');
        }
        if (requestParameters.buildIndividualTestersLinkagesRequest === null || requestParameters.buildIndividualTestersLinkagesRequest === undefined) {
            throw new runtime.RequiredError('buildIndividualTestersLinkagesRequest', 'Required parameter requestParameters.buildIndividualTestersLinkagesRequest was null or undefined when calling buildsIndividualTestersCreateToManyRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/individualTesters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BuildIndividualTestersLinkagesRequestToJSON(requestParameters.buildIndividualTestersLinkagesRequest),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async buildsIndividualTestersCreateToManyRelationship(requestParameters: BuildsIndividualTestersCreateToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.buildsIndividualTestersCreateToManyRelationshipRaw(requestParameters, initOverrides);
    }
    /**
     */
    async buildsIndividualTestersDeleteToManyRelationshipRaw(requestParameters: BuildsIndividualTestersDeleteToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsIndividualTestersDeleteToManyRelationship.');
        }
        if (requestParameters.buildIndividualTestersLinkagesRequest === null || requestParameters.buildIndividualTestersLinkagesRequest === undefined) {
            throw new runtime.RequiredError('buildIndividualTestersLinkagesRequest', 'Required parameter requestParameters.buildIndividualTestersLinkagesRequest was null or undefined when calling buildsIndividualTestersDeleteToManyRelationship.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/individualTesters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: BuildIndividualTestersLinkagesRequestToJSON(requestParameters.buildIndividualTestersLinkagesRequest),
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     */
    async buildsIndividualTestersDeleteToManyRelationship(requestParameters: BuildsIndividualTestersDeleteToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.buildsIndividualTestersDeleteToManyRelationshipRaw(requestParameters, initOverrides);
    }
    /**
     */
    async buildsIndividualTestersGetToManyRelatedRaw(requestParameters: BuildsIndividualTestersGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BetaTestersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsIndividualTestersGetToManyRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsBetaTesters) {
            queryParameters['fields[betaTesters]'] = requestParameters.fieldsBetaTesters.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/individualTesters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BetaTestersResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsIndividualTestersGetToManyRelated(requestParameters: BuildsIndividualTestersGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BetaTestersResponse> {
        const response = await this.buildsIndividualTestersGetToManyRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsIndividualTestersGetToManyRelationshipRaw(requestParameters: BuildsIndividualTestersGetToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildIndividualTestersLinkagesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsIndividualTestersGetToManyRelationship.');
        }
        const queryParameters: any = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/relationships/individualTesters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildIndividualTestersLinkagesResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsIndividualTestersGetToManyRelationship(requestParameters: BuildsIndividualTestersGetToManyRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildIndividualTestersLinkagesResponse> {
        const response = await this.buildsIndividualTestersGetToManyRelationshipRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsPerfPowerMetricsGetToManyRelatedRaw(requestParameters: BuildsPerfPowerMetricsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<XcodeMetrics>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsPerfPowerMetricsGetToManyRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.filterDeviceType) {
            queryParameters['filter[deviceType]'] = requestParameters.filterDeviceType.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterMetricType) {
            queryParameters['filter[metricType]'] = requestParameters.filterMetricType.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        if (requestParameters.filterPlatform) {
            queryParameters['filter[platform]'] = requestParameters.filterPlatform.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/perfPowerMetrics`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => XcodeMetricsFromJSON(jsonValue));
    }
    /**
     */
    async buildsPerfPowerMetricsGetToManyRelated(requestParameters: BuildsPerfPowerMetricsGetToManyRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<XcodeMetrics> {
        const response = await this.buildsPerfPowerMetricsGetToManyRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsPreReleaseVersionGetToOneRelatedRaw(requestParameters: BuildsPreReleaseVersionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrereleaseVersionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsPreReleaseVersionGetToOneRelated.');
        }
        const queryParameters: any = {};
        if (requestParameters.fieldsPreReleaseVersions) {
            queryParameters['fields[preReleaseVersions]'] = requestParameters.fieldsPreReleaseVersions.join(runtime.COLLECTION_FORMATS["csv"]);
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}/preReleaseVersion`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => PrereleaseVersionResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsPreReleaseVersionGetToOneRelated(requestParameters: BuildsPreReleaseVersionGetToOneRelatedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrereleaseVersionResponse> {
        const response = await this.buildsPreReleaseVersionGetToOneRelatedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     */
    async buildsUpdateInstanceRaw(requestParameters: BuildsUpdateInstanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling buildsUpdateInstance.');
        }
        if (requestParameters.buildUpdateRequest === null || requestParameters.buildUpdateRequest === undefined) {
            throw new runtime.RequiredError('buildUpdateRequest', 'Required parameter requestParameters.buildUpdateRequest was null or undefined when calling buildsUpdateInstance.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("itcBearerToken", []);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/builds/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BuildUpdateRequestToJSON(requestParameters.buildUpdateRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => BuildResponseFromJSON(jsonValue));
    }
    /**
     */
    async buildsUpdateInstance(requestParameters: BuildsUpdateInstanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildResponse> {
        const response = await this.buildsUpdateInstanceRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
/**
 * @export
 */
export type BuildsAppEncryptionDeclarationGetToOneRelatedFieldsAppEncryptionDeclarationsEnum = 'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption';;
/**
 * @export
 */
export type BuildsAppGetToOneRelatedFieldsAppsEnum = 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionExperimentsEnum = 'appStoreVersion' | 'appStoreVersionExperimentTreatments' | 'endDate' | 'name' | 'reviewRequired' | 'startDate' | 'started' | 'state' | 'trafficProportion';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAgeRatingDeclarationsEnum = 'alcoholTobaccoOrDrugUseOrReferences' | 'contests' | 'gambling' | 'gamblingAndContests' | 'gamblingSimulated' | 'horrorOrFearThemes' | 'kidsAgeBand' | 'matureOrSuggestiveThemes' | 'medicalOrTreatmentInformation' | 'profanityOrCrudeHumor' | 'seventeenPlus' | 'sexualContentGraphicAndNudity' | 'sexualContentOrNudity' | 'unrestrictedWebAccess' | 'violenceCartoonOrFantasy' | 'violenceRealistic' | 'violenceRealisticProlongedGraphicOrSadistic';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionSubmissionsEnum = 'appStoreVersion';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreReviewDetailsEnum = 'appStoreReviewAttachments' | 'appStoreVersion' | 'contactEmail' | 'contactFirstName' | 'contactLastName' | 'contactPhone' | 'demoAccountName' | 'demoAccountPassword' | 'demoAccountRequired' | 'notes';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionsEnum = 'ageRatingDeclaration' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'routingAppCoverage' | 'versionString';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppsEnum = 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsRoutingAppCoveragesEnum = 'appStoreVersion' | 'assetDeliveryState' | 'fileName' | 'fileSize' | 'sourceFileChecksum' | 'uploadOperations' | 'uploaded';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppClipDefaultExperiencesEnum = 'action' | 'appClip' | 'appClipAppStoreReviewDetail' | 'appClipDefaultExperienceLocalizations' | 'appClipDefaultExperienceTemplate' | 'releaseWithAppStoreVersion';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionPhasedReleasesEnum = 'appStoreVersion' | 'currentDayNumber' | 'phasedReleaseState' | 'startDate' | 'totalPauseDuration';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsBuildsEnum = 'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedFieldsAppStoreVersionLocalizationsEnum = 'appPreviewSets' | 'appScreenshotSets' | 'appStoreVersion' | 'description' | 'keywords' | 'locale' | 'marketingUrl' | 'promotionalText' | 'supportUrl' | 'whatsNew';;
/**
 * @export
 */
export type BuildsAppStoreVersionGetToOneRelatedIncludeEnum = 'ageRatingDeclaration' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreVersionExperiments' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'routingAppCoverage';;
/**
 * @export
 */
export type BuildsBetaAppReviewSubmissionGetToOneRelatedFieldsBetaAppReviewSubmissionsEnum = 'betaReviewState' | 'build' | 'submittedDate';;
/**
 * @export
 */
export type BuildsBetaBuildLocalizationsGetToManyRelatedFieldsBetaBuildLocalizationsEnum = 'build' | 'locale' | 'whatsNew';;
/**
 * @export
 */
export type BuildsBuildBetaDetailGetToOneRelatedFieldsBuildBetaDetailsEnum = 'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState';;
/**
 * @export
 */
export type BuildsDiagnosticSignaturesGetToManyRelatedFilterDiagnosticTypeEnum = 'DISK_WRITES' | 'HANGS';;
/**
 * @export
 */
export type BuildsDiagnosticSignaturesGetToManyRelatedFieldsDiagnosticSignaturesEnum = 'diagnosticType' | 'logs' | 'signature' | 'weight';;
/**
 * @export
 */
export type BuildsGetCollectionFilterBetaAppReviewSubmissionBetaReviewStateEnum = 'WAITING_FOR_REVIEW' | 'IN_REVIEW' | 'REJECTED' | 'APPROVED';;
/**
 * @export
 */
export type BuildsGetCollectionFilterBuildAudienceTypeEnum = 'INTERNAL_ONLY' | 'APP_STORE_ELIGIBLE';;
/**
 * @export
 */
export type BuildsGetCollectionFilterPreReleaseVersionPlatformEnum = 'IOS' | 'MAC_OS' | 'TV_OS';;
/**
 * @export
 */
export type BuildsGetCollectionFilterProcessingStateEnum = 'PROCESSING' | 'FAILED' | 'INVALID' | 'VALID';;
/**
 * @export
 */
export type BuildsGetCollectionSortEnum = 'preReleaseVersion' | '-preReleaseVersion' | 'uploadedDate' | '-uploadedDate' | 'version' | '-version';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBuildsEnum = 'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version';;
/**
 * @export
 */
export type BuildsGetCollectionIncludeEnum = 'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsDiagnosticSignaturesEnum = 'diagnosticType' | 'logs' | 'signature' | 'weight';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBuildIconsEnum = 'iconAsset' | 'iconType' | 'name';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBuildBetaDetailsEnum = 'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBetaAppReviewSubmissionsEnum = 'betaReviewState' | 'build' | 'submittedDate';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBetaTestersEnum = 'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsAppStoreVersionsEnum = 'ageRatingDeclaration' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'routingAppCoverage' | 'versionString';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsBetaBuildLocalizationsEnum = 'build' | 'locale' | 'whatsNew';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsPreReleaseVersionsEnum = 'app' | 'builds' | 'platform' | 'version';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsAppEncryptionDeclarationsEnum = 'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsAppsEnum = 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox';;
/**
 * @export
 */
export type BuildsGetCollectionFieldsPerfPowerMetricsEnum = 'deviceType' | 'metricType' | 'platform';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBuildsEnum = 'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildAudienceType' | 'buildBetaDetail' | 'buildBundles' | 'computedMinMacOsVersion' | 'diagnosticSignatures' | 'expirationDate' | 'expired' | 'iconAssetToken' | 'icons' | 'individualTesters' | 'lsMinimumSystemVersion' | 'minOsVersion' | 'perfPowerMetrics' | 'preReleaseVersion' | 'processingState' | 'uploadedDate' | 'usesNonExemptEncryption' | 'version';;
/**
 * @export
 */
export type BuildsGetInstanceIncludeEnum = 'app' | 'appEncryptionDeclaration' | 'appStoreVersion' | 'betaAppReviewSubmission' | 'betaBuildLocalizations' | 'betaGroups' | 'buildBetaDetail' | 'buildBundles' | 'icons' | 'individualTesters' | 'preReleaseVersion';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsDiagnosticSignaturesEnum = 'diagnosticType' | 'logs' | 'signature' | 'weight';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBuildIconsEnum = 'iconAsset' | 'iconType' | 'name';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBuildBetaDetailsEnum = 'autoNotifyEnabled' | 'build' | 'externalBuildState' | 'internalBuildState';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBetaAppReviewSubmissionsEnum = 'betaReviewState' | 'build' | 'submittedDate';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBetaTestersEnum = 'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsAppStoreVersionsEnum = 'ageRatingDeclaration' | 'app' | 'appClipDefaultExperience' | 'appStoreReviewDetail' | 'appStoreState' | 'appStoreVersionExperiments' | 'appStoreVersionLocalizations' | 'appStoreVersionPhasedRelease' | 'appStoreVersionSubmission' | 'build' | 'copyright' | 'createdDate' | 'customerReviews' | 'downloadable' | 'earliestReleaseDate' | 'platform' | 'releaseType' | 'routingAppCoverage' | 'versionString';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsBetaBuildLocalizationsEnum = 'build' | 'locale' | 'whatsNew';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsPreReleaseVersionsEnum = 'app' | 'builds' | 'platform' | 'version';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsAppEncryptionDeclarationsEnum = 'app' | 'appDescription' | 'appEncryptionDeclarationDocument' | 'appEncryptionDeclarationState' | 'availableOnFrenchStore' | 'builds' | 'codeValue' | 'containsProprietaryCryptography' | 'containsThirdPartyCryptography' | 'createdDate' | 'documentName' | 'documentType' | 'documentUrl' | 'exempt' | 'platform' | 'uploadedDate' | 'usesEncryption';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsAppsEnum = 'appAvailability' | 'appClips' | 'appCustomProductPages' | 'appEvents' | 'appInfos' | 'appPricePoints' | 'appPriceSchedule' | 'appStoreVersions' | 'availableInNewTerritories' | 'availableTerritories' | 'betaAppLocalizations' | 'betaAppReviewDetail' | 'betaGroups' | 'betaLicenseAgreement' | 'betaTesters' | 'builds' | 'bundleId' | 'ciProduct' | 'contentRightsDeclaration' | 'customerReviews' | 'endUserLicenseAgreement' | 'gameCenterEnabledVersions' | 'inAppPurchases' | 'inAppPurchasesV2' | 'isOrEverWasMadeForKids' | 'name' | 'perfPowerMetrics' | 'preOrder' | 'preReleaseVersions' | 'pricePoints' | 'prices' | 'primaryLocale' | 'promotedPurchases' | 'reviewSubmissions' | 'sku' | 'subscriptionGracePeriod' | 'subscriptionGroups' | 'subscriptionStatusUrl' | 'subscriptionStatusUrlForSandbox' | 'subscriptionStatusUrlVersion' | 'subscriptionStatusUrlVersionForSandbox';;
/**
 * @export
 */
export type BuildsGetInstanceFieldsPerfPowerMetricsEnum = 'deviceType' | 'metricType' | 'platform';;
/**
 * @export
 */
export type BuildsIconsGetToManyRelatedFieldsBuildIconsEnum = 'iconAsset' | 'iconType' | 'name';;
/**
 * @export
 */
export type BuildsIndividualTestersGetToManyRelatedFieldsBetaTestersEnum = 'apps' | 'betaGroups' | 'builds' | 'email' | 'firstName' | 'inviteType' | 'lastName';;
/**
 * @export
 */
export type BuildsPerfPowerMetricsGetToManyRelatedFilterMetricTypeEnum = 'DISK' | 'HANG' | 'BATTERY' | 'LAUNCH' | 'MEMORY' | 'ANIMATION' | 'TERMINATION';;
/**
 * @export
 */
export type BuildsPerfPowerMetricsGetToManyRelatedFilterPlatformEnum = 'IOS';;
/**
 * @export
 */
export type BuildsPreReleaseVersionGetToOneRelatedFieldsPreReleaseVersionsEnum = 'app' | 'builds' | 'platform' | 'version';;
